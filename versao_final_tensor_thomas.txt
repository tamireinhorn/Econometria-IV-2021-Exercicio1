---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

First, packages will be loaded.

```{r}
library(readr)
library(dplyr)
library(stringr)
```

Now, files will be read and a list with clean data will be created:

```{r}

files=list.files('Data') #creates list with names of all files 

all_stocks <- vector(mode = "list", length = 30) #creates an empty list 
 
#the created list will be filled with each data file (which will be read as a dataframe) 
 
for (i in 1:length(files)) { 
     
    name <- paste("Data/",files[i], sep = "") 
    all_stocks[i] <- files[i] 
    all_stocks[[i]] <- read.csv(name) 
    print(files[i]) 
}

#the date column will be converted into date format 

convert_to_date <- function(x){ 
  x$Date <- as.Date(as.character(x$Date), format='%m/%d/%Y') 
  x 
} 

#a lapply command will impose the date convertion for all companies in all_stocks

new_all_stocks <- lapply(all_stocks, convert_to_date)

#a function will be created to filter data for each company as of 2000, and this will be applied to the entire list of companies

as_of_2000 <- function(ticker){ 
new_ticker <- filter(ticker, format(ticker$Date, '%Y') >= 2000)  
return(new_ticker) 
} 


#Such function will be applied to the list through lapply, and clean_data will be the list with 30 clean data frames, with a formatted date and observations starting in 2000

clean_data <- lapply(new_all_stocks,as_of_2000) 

names(clean_data) <- str_sub(files, end=-5) #assign a name to each company (excludes .txt)
```

Now, the tensor for each firm will be created. A tensor will be created for a single firm (referred to as "ticker") and then for the rest through lapply

```{r}

make_data_thomas <- function(ticker){
  
  #Create a list of all existing minutes
  minute_list <- sort(unique(ticker$Time))
  
  #the minute_list was converted into a df only so it can be used for the left join adjustment
  minute_df <- data.frame('Time' = minute_list)   

  dias <- unique(ticker$Date)
  n <- length(dias)

  #a list is created for the ticker, containing all the days in which it operated
  list <- vector(mode = "list", length =  n) 
  for(j in 1:n){
    day_df <- ticker[ticker$Date == dias[j],] #df containing information on day j
    adj_day_df <- left_join(minute_df, day_df, by = 'Time') #This is the dataframe with all data for all possible minutes, whether they have observations that day or not. This is just an ajustment so all companies are similar in dimension.
    
    list[[j]] <- vector(mode = 'list', length = 390) #Creates an inner list representing all minutes of day j, for the ticker
    
    for (minute in 1:390){ #Now we loop over all possible minutes
      
    inner_variable_list <- vector(mode = 'list', length = 9) #This will have the length equal to number of variables of interest
    names(inner_variable_list) <- c("Day", "Month", "Year", "Open", "Close", "Low", "High", "Volume","r_cc")
      
    list[[j]][[minute]] <- inner_variable_list #each minute of the day is effectively receiving the vector of variables, and we`ll fill this vector next. Here, we explicit that list[[j]][[min]] is a list on its own, by associating it with inner_variable_list, which is a list
      
    df_minute <- adj_day_df[adj_day_df$Time == minute_list[minute],] ##We open the dataframe minute by minute
      
    This chunk will be used for the r_cc    

    if (minute==1){
       jif=0
  }
    else {
       jif=1
  }  
        
    df_minute_minus <- adj_day_df[adj_day_df$Time == minute_list[minute-jif],]
      
      #finally, a minute of day j is receiving relevant economic variables	      

      #list[[j]][[minute]][[1]] <- df_minute$format(df_minute$Date,'%d')
      #list[[j]][[minute]][[2]] <- df_minute$format(df_minute$Date,'%m')
      #list[[j]][[minute]][[3]] <- df_minute$format(df_minute$Date,'%y')
      list[[j]][[minute]][[4]] <- df_minute$Open
      list[[j]][[minute]][[5]] <- df_minute$Close
      list[[j]][[minute]][[6]] <- df_minute$Low
      list[[j]][[minute]][[7]] <- df_minute$High
      list[[j]][[minute]][[8]] <- df_minute$Volume
      list[[j]][[minute]][[9]] <- (df_minute$Close - df_minute_minus$Close)/(df_minute_minus$Close)
    }
    
  }
  return(list)
}
```

```{r}
#testando para AXP
tensor_axp_thomas <- make_data_thomas(clean_data$AXP)
tensor_axp_thomas[[1]][[3]]$Open
```

```{r}
#below, the function make_data() is applied to all companies 

<<<<<<< Updated upstream
#tenson_clean_data <- lapply(clean_data, make_data)

#or

=======
>>>>>>> Stashed changes
#for (i in clean_data) {

   paste('tensor',i,sep="_") <- make_data_thomas(i)

}

```

















```{r}

make_data_tamir <- function(ticker){
  
  ##So here's the deal: I want a list of dataframes, all with the same length of minutes.
  ##But i want every element of this list to be a list in itself: the first element is the DATE of the dataframe, the second is the dataframe itself. 
  ##Create a list of ALL existing minutes
  
  minute_list <- sort(unique(ticker$Time))
  minute_df <- data.frame('Time' = minute_list) ##This df is      used only for the left join 
  
  dias <- unique(ticker$Date)
  n <- length(dias)
  
 #we create a list for each day
  
  list <- vector(mode = "list", length =  n)
  for(j in 1:n){
    day_df <- ticker[ticker$Date == dias[j],]
    adj_day_df <- left_join(minute_df, day_df, by = 'Time') ##This is the dataframe with all data for all possible minutes, whether they have observations that day or not
    
    list[[j]] <- vector(mode = 'list', length = 390) ##Creates the inner list for each day, that is, for each day j we create a list with 390 minutes
    
    for (minute in 1:390){ #Now we loop over all possible minutes, allowing each one to receive several economic variables}
      
      inner_variable_list <- vector(mode = 'list', length = 9) ##This will have the length of all variables you want
      names(inner_variable_list) <- c("Day", "Month", "Year", "Open", "Close", "Low", "High", "Volume","r_cc")
      
      
      
      list[[j]][[minute]] <- inner_variable_list #each minute of the day is effectively receiving the vector of variables, and we`ll fill this vector next. Here, we explicit that list[[j]][[min]] is a list on its own.
      
      df_minute <- adj_day_df[adj_day_df$Time == minute_list[minute],] ##We open the dataframe minute by minute
      
      
      if (minute==1){
       jif=0
  }
      else {
       jif=1
  }  
        
      df_minute_minus <- adj_day_df[adj_day_df$Time == minute_list[minute-jif],]
      
      list[[j]][[minute]][[1]] <- df_minute$format(df_minute$Date,'%d')
      list[[j]][[minute]][[2]] <- df_minute$format(df_minute$Date,'%m')
      list[[j]][[minute]][[3]] <- df_minute$format(df_minute$Date,'%y')
      list[[j]][[minute]][[4]] <- df_minute$Open
      list[[j]][[minute]][[5]] <- df_minute$Close
      list[[j]][[minute]][[6]] <- df_minute$Low
      list[[j]][[minute]][[7]] <- df_minute$High
      list[[j]][[minute]][[8]] <- df_minute$Volume
      list[[j]][[minute]][[9]] <- (df_minute$Close - df_minute_minus$Close)/(df_minute_minus$Close)
    }
    
  }
  return(list)
}

#Testing make_data_tamir for certain company
```

```{r}

tensor_axp_tamir <- make_data_tamir(clean_data$AXP)

tensor_axp_tamir[[1]][[3]][[4]]

#rodar Ã s 30
#mandar R.data