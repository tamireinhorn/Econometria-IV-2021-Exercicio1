---
title: "Exercise 1"
output: html_notebook

---
LOADING PACKAGES:

```{r}
library(tidyverse)
library(dplyr)
library(tsibble)
library(feasts)
library(stringr)
library(lubridate)
library(anytime)
library(ggplot2)
library(ggthemes)
library(knitr)
library(kableExtra)
library(DT)
library(htmltools)
library(reshape2) #to be used with tidyverse and gglopt2
library(ggpubr)
```

2. DATA PREPARATION

The function clean_data will be created to clean the files, and it will be applied in the second chunk of the code, in which we will import the files.

```{r}
clean_data <- function(ticker) {

  ##In this function, we're going to first convert the Date column to date:
 
     ticker$Date <- as.Date(ticker$Date, '%m/%d/%Y')
  
  ## Then, we want to restrict it from 2000 onwards

     new_ticker <- filter(ticker, format(ticker$Date, '%Y') >= 2000)

     ##We need all days to contain the same number ofminutes, so we will use the left_join command first ensure that, and also to create NA for all MINUTES for which certain stocks do not have data.
     
     minute_list <- sort(unique(new_ticker$Time)) 
     day_list <- sort(unique(new_ticker$Date))
     minute_df <- data.frame('Time' = minute_list) ##A minute df is needed for the left_join() to be applied
     day_df <- data.frame('Date' = day_list) ##A day df is needed for the left_join() to be applied
     day_minute_df <- left_join(day_df, minute_df, character()) ##A df is created in which all 390 possible minutes were joined into each possible day
     new_ticker <- left_join(day_minute_df, new_ticker, by = c('Time', 'Date')) ##Then we left join all the informations in the new ticker into the day_minute df, uniformising all dates for all stocks in number of minutes
     new_ticker$minute_return <- (new_ticker$Close - lag(new_ticker$Close))/ new_ticker$Close ##Return taken on levels: p_t - p_{t-1} / p_{t-1}
     new_ticker$minute_log_return <- log(new_ticker$Close) - log(lag(new_ticker$Close)) ##Log return: log(p_t) - log(p_{t-1})
     
  return(new_ticker)
}
```

Given the clean_data() function above, we will now jointly import and clean the data (alternatively, we could have importer everything, then created the cleaning function and then have applied it, using three different chunks). 


```{r}
files_list <- list.files('Data')
stock_name <- str_remove(files_list, ".txt")
stock_list <- vector(mode = "list", length = 30) ##Initialize the stock list.
for (i in 1:length(stock_list)) {
  stock_df <- data.frame(read_csv(paste('Data/',files_list[i], sep = ""), col_types = cols())) 
  clean_stock_df <- clean_data(stock_df)
  stock_list[[i]] <- clean_stock_df[,]
}

names(stock_list) <- stock_name
```

A function to compute daily variables of interest will be created, and in a following code it will be applied to our list of stocks. These variables of interest are the realized volatility, sum of daily minute returns and sum of daily volumes traded per minute:

```{r}

#First for AXP, to understand the logic
#AXP %>% group_by(Date) %>% summarise(daily=sum(minute_log_return,na.rm=T), RV = sum(minute_log_return^2, na.rm = T), VOL = sum(Volume, na.rm = T), log_RV = log(sum(minute_log_return^2, na.rm = T)) ) ##This works as intended, just creates our daily dataframe. Therefore

##This logic will be turned into a function that creates daily dataframes for all of the tickers

make_daily_data <- function(clean_ticker){
  daily_ticker <- clean_ticker %>% group_by(Date) %>% summarise(daily=sum(minute_log_return,na.rm=T), RV = sum(minute_log_return^2, na.rm = T), VOL = sum(Volume, na.rm = T), log_RV = log(sum(minute_log_return^2, na.rm = T)) )
  #return(daily_ticker)
}
```

Now, we apply this function for all tickers, just like before.

```{r}
daily_stock_list <- vector(mode = 'list', length = 30) ##Initialize the daily stock list.

for (i in 1:length(stock_list)) {

  daily_stock_df <- make_daily_data(stock_list[[i]])
  daily_stock_list[[i]] <- daily_stock_df[,]
  
}
names(daily_stock_list) <- stock_name

str(daily_stock_list[1])
head(daily_stock_list[1],n=5)

```
As suggested, we should try creating one giant dataframe in order to use facet_wrap and plot everything at once.

```{r}
complete_daily_df <- bind_rows(daily_stock_list, .id = "column_label")
##I just want the name to be Stock:
names(complete_daily_df)[names(complete_daily_df)== 'column_label'] <- 'Stock'
```
```{r}
##I really want to see the max value for all RV to establish plot limits.

z<- complete_daily_df %>% group_by(Stock) %>% summarise(max(RV))
names(z) <- c('Stock', 'MaxRV')
maxRVplot <-z %>% summarise(mean(MaxRV))
```


Now, for a simple plot:

```{r fig.height = 30, fig.width = 14}
ggplot(complete_daily_df, aes(x = RV)) +
  geom_histogram(aes(y = ..density..),bins= 200, color = "darkblue", fill = "lightblue") + xlim(0, maxRVplot[[1]]) +
  labs(title = "RV Histograms", x = "", y = "")   +
  facet_wrap(~ Stock, ncol = 4, scales = 'free') +
  theme_minimal()


```

Testing out this package that groups graphs. 
```{r}
data("ToothGrowth")
head(ToothGrowth)
mtcars$name <- rownames(mtcars)
mtcars$cyl <- as.factor(mtcars$cyl)
bxp <- ggboxplot(ToothGrowth, x = "dose", y = "len",
                 color = "dose", palette = "jco") + labs(title = 'bolinh')

# Dot plot (dp)
dp <- ggdotplot(ToothGrowth, x = "dose", y = "len",
                 color = "dose", palette = "jco", binwidth = 1)
bp <- ggbarplot(mtcars, x = "name", y = "mpg",
          fill = "cyl",               # change fill color by cyl
          color = "white",            # Set bar border colors to white
          palette = "jco",            # jco journal color palett. see ?ggpar
          sort.val = "asc",           # Sort the value in ascending order
          sort.by.groups = TRUE,      # Sort inside each group
          x.text.angle = 90           # Rotate vertically x axis texts
          )

# Scatter plots (sp)
sp <- ggscatter(mtcars, x = "wt", y = "mpg",
                add = "reg.line",               # Add regression line
                conf.int = TRUE,                # Add confidence interval
                color = "cyl", palette = "jco", # Color by groups "cyl"
                shape = "cyl"                   # Change point shape by groups "cyl"
                )+
  stat_cor(aes(color = cyl), label.x = 3)       # Add correlation coefficient
ggarrange(bxp, dp, bp + rremove("x.text"), 
          labels = c("A", "B", "C"),
          ncol = 2, nrow = 2)
```
sss
```{r}
complete_daily_df %>% 
  group_by(Stock, Date) %>% 
  mutate(RV = 100*min(RV, 0.001)) %>%
  nest(data = c(RV, VOL, Date)) %>% 
  mutate(y = map(data, ~ dnorm(.$RV, mean = mean(.$RV), sd = sd(.$RV)) * 0.001 * sum(!is.na(.$RV)))) %>% 
  unnest(c(data,y)) %>% 
  ggplot(aes(x = RV)) +
  geom_histogram(binwidth = 0.001) +
  geom_line(aes(y = y, color = 'red')) +
  facet_wrap(~ Asset, ncol = 4, scales = 'free') +
  labs(x = "", y = "", title = 'Realized Volatility Histograms (in percentage terms, %)', subtitle = 'Normal density in red') +
  theme_bw() + theme(legend.position = "none")
```
Let's try plotting them all together
```{r}
#ggarrange(plotlist = plot_list, ncol = 5, nrow = 3)
g <- ggplot(daily_stock_list[[i]], aes(x = RV))  + geom_histogram(aes(y = ..density..), binwidth = 0.0001, colour = "black") +stat_function(fun = dnorm, args = list(mean = mean(daily_stock_list[[i]]$RV), sd = sd(daily_stock_list[[i]]$RV)))

## On primary axis

```

I want to test the solutions to plot a normal distribution for ONE of the RV series we have.

```{r}
i
```

